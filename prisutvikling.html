<!doctype html>
<html lang="no">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Boligprisindeks â€“ Oslo</title>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <style>
    :root {
      --bg: #0f1114;
      --text: rgba(255, 255, 255, 0.92);
      --muted: rgba(255, 255, 255, 0.60);
      --grid: rgba(255, 255, 255, 0.07);
    }

    html,
    body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .wrap {
      max-width: 1200px;
      margin: 0 auto;
      padding: 18px 16px 34px 16px;
    }

    #chart {
      width: 100%;
      aspect-ratio: 4 / 3;
    }

    /* Tooltip */
    .mi-tooltip {
      position: fixed;
      display: none;
      z-index: 9999;
      background: rgba(16, 18, 22, 0.94);
      color: rgba(255, 255, 255, 0.94);
      border-radius: 12px;
      box-shadow: 0 28px 80px rgba(0, 0, 0, 0.65);
      padding: 14px;
      width: 360px;
      max-width: calc(100vw - 24px);
      max-height: min(560px, calc(100vh - 24px));
      overflow: auto;
      pointer-events: none;
    }

    .mi-tooltip::after {
      content: "";
      position: absolute;
      top: 22px;
      right: -10px;
      border-top: 10px solid transparent;
      border-bottom: 10px solid transparent;
      border-left: 10px solid rgba(16, 18, 22, 0.94);
    }

    .mi-tooltip .date {
      font-size: 18px;
      font-weight: 800;
      margin-bottom: 10px;
    }

    .mi-tooltip .rows {
      display: grid;
      grid-template-columns: 12px 1fr auto;
      gap: 8px 10px;
      font-size: 14px;
    }

    .mi-tooltip .label.hero {
      font-weight: 900;
    }

    /* Dual Range Sliders */
    .chart-wrapper {
      position: relative;
      width: 100%;
      aspect-ratio: 4 / 3;
    }

    .y-slider-container {
      position: absolute;
      left: 0px;
      top: 60px;
      bottom: 260px;
      width: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    /* Slider Base Styles */
    .y-range-slider,
    .x-range-slider {
      background: rgba(255, 255, 255, 0.04);
      border-radius: 2px;
    }

    /* Track (Background) */
    .y-range-slider .track,
    .x-range-slider .track {
      background: rgba(255, 255, 255, 0.12);
      /* Dark grey active track */
      border-radius: 0;
      position: absolute;
      /* Ensure positioning works with JS */
    }

    .y-range-slider .track {
      width: 100%;
    }

    .x-range-slider .track {
      height: 100%;
    }

    /* Thumbs (Handles) */
    .y-range-slider input[type="range"]::-webkit-slider-thumb,
    .x-range-slider input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      box-shadow: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.05);
      /* Transparent/Glassy */
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.25);
      /* Subtle border */
      backdrop-filter: blur(2px);
      pointer-events: all;
    }

    .y-range-slider input[type="range"]::-moz-range-thumb,
    .x-range-slider input[type="range"]::-moz-range-thumb {
      box-shadow: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.05);
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.25);
      backdrop-filter: blur(2px);
      pointer-events: all;
    }

    .x-slider-container {
      position: absolute;
      left: 80px;
      right: 24px;
      bottom: 175px;
      /* Positioned cleanly between X-axis labels and legend */
      height: 30px;
      display: flex;
      align-items: center;
      z-index: 100;
    }

    /* Container specific styling */
    .y-range-slider {
      width: 3px;
      /* Thinner */
      height: 100%;
      position: relative;
    }

    .y-range-slider input[type="range"] {
      position: absolute;
      /* Width set dynamically by JS to match container height */
      width: 100%;
      height: 30px;
      background: transparent;
      pointer-events: none;
      -webkit-appearance: none;
      appearance: none;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%) rotate(-90deg);
      margin: 0;
    }

    .x-range-slider {
      width: 100%;
      height: 3px;
      /* Thinner */
      position: relative;
    }

    .x-range-slider input[type="range"] {
      position: absolute;
      width: 100%;
      height: 30px;
      top: 50%;
      transform: translateY(-50%);
      background: transparent;
      pointer-events: none;
      -webkit-appearance: none;
      appearance: none;
      margin: 0;
    }

    @media (max-width: 640px) {
      #chart {
        height: 600px;
      }

      .mi-tooltip {
        width: 300px;

      }
    }

    .trace.scatter:first-of-type path.js-fill {
      fill: url(#blueGradient) !important;
      fill-opacity: 1 !important;
    }
  </style>

</head>

<body>
  <svg width="0" height="0" style="position: absolute; pointer-events: none;">
    <defs>
      <linearGradient id="blueGradient" x1="0" x2="0" y1="0" y2="1">
        <stop offset="0%" stop-color="#1E88FF" stop-opacity="0.25" />
        <stop offset="80%" stop-color="#1E88FF" stop-opacity="0" />
      </linearGradient>
    </defs>
  </svg>
  <div class="wrap">
    <div class="chart-wrapper">
      <div id="chart"></div>

      <!-- Y-axis dual range slider -->
      <div class="y-slider-container">
        <div class="y-range-slider">
          <div class="track"></div>
          <input type="range" min="50" max="300" value="110" id="yRangeMin" orient="vertical">
          <input type="range" min="50" max="300" value="290" id="yRangeMax" orient="vertical">
        </div>
      </div>

      <!-- X-axis dual range slider -->
      <div class="x-slider-container">
        <div class="x-range-slider">
          <div class="track"></div>
          <input type="range" min="0" max="91" value="36" id="xRangeMin">
          <input type="range" min="0" max="91" value="91" id="xRangeMax">
        </div>
      </div>
    </div>
  </div>
  <div id="miTooltip" class="mi-tooltip"></div>

  <script>
    // Async Plotly loading wrapper
    function initChart() {
      if (typeof Plotly === 'undefined') {
        console.log('Plotly not loaded yet, retrying...');
        setTimeout(initChart, 50);
        return;
      }

      console.log('Plotly loaded, initializing chart...');


// --- CONFIG ---
Promise.all([
    fetch('data.csv').then(r => r.text()),
    fetch('layout.json').then(r => r.json()),
    fetch('config.json').then(r => r.json())
]).then(([csvText, layoutJson, configJson]) => {

    const AREA_COLORS = configJson.colors;
    const HERO = configJson.hero;

    // Parse CSV
    const lines = csvText.trim().split('\n');
    const headers = lines[0].split(',');
    const areaNames = headers.slice(1);

    const dates = [];
    const areaValues = {};
    areaNames.forEach(a => areaValues[a] = []);

    for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        const cols = line.split(',');
        dates.push(cols[0]);
        for (let j = 1; j < cols.length; j++) {
            const val = cols[j] === '' ? null : parseFloat(cols[j]);
            areaValues[areaNames[j - 1]].push(val);
        }
    }

    // Build Traces
    const traces = [];
    areaNames.forEach(name => {
        const isHero = name === HERO;
        const trace = {
            x: dates,
            y: areaValues[name],
            type: 'scatter',
            mode: 'lines',
            name: name,
            line: {
                color: AREA_COLORS[name] || '#999',
                shape: 'spline',
                smoothing: 1.2,
                width: isHero ? 3.5 : 2.4
            },
            opacity: isHero ? 1.0 : 0.85,
            hoverinfo: 'none',
            hovertemplate: '<extra></extra>'
        };
        if (isHero) {
            trace.fill = 'tozeroy';
            trace.fillcolor = 'rgba(30,136,255,0.14)';
        }
        traces.push(trace);
    });

    // Re-assemble objects
    const FIG = {
        data: traces,
        layout: layoutJson
    };

    const LOOKUP = {
        dates: dates,
        areas: areaNames,
        values: areaValues,
        colors: AREA_COLORS,
        hero: HERO
    };

    const chartEl = document.getElementById('chart');
    const tipEl = document.getElementById('miTooltip');
    // check if elements exist
    if (!chartEl || !tipEl) return;

    const config = {
        responsive: true,
        displaylogo: false,
        modeBarButtonsToRemove: ['select2d', 'lasso2d'],
    };

    // Add bottom margin to layout
    FIG.layout.margin.b = 160;

    function formatDateISOToNO(iso) {
        const [y, m, d] = iso.split('-');
        return `${d}.${m}.${y}`;
    }
    function formatNumberNO(x) {
        if (x === null || x === undefined || Number.isNaN(x)) return '';
        return x.toFixed(2).replace('.', ',');
    }

    const dateIndex = Object.create(null);
    LOOKUP.dates.forEach((d, i) => dateIndex[d] = i);

    function buildTooltipHTML(dateISO, orderAreas) {
        const idx = dateIndex[dateISO];
        let rows = '';
        for (const area of orderAreas) {
            const v = idx !== undefined ? LOOKUP.values[area][idx] : null;
            rows += `
          <div class="dot" style="background:${LOOKUP.colors[area]}"></div>
          <div class="label ${area === LOOKUP.hero ? 'hero' : ''}">${area}</div>
          <div class="val">${formatNumberNO(v)}</div>
        `;
        }
        return `<div class="date">${formatDateISOToNO(dateISO)}</div><div class="rows">${rows}</div>`;
    }

    function positionTooltip(evt) {
        const r = tipEl.getBoundingClientRect();
        let x = evt.clientX - r.width - 18;
        let y = evt.clientY - 26;
        const pad = 10;
        if (x < pad) x = pad;
        if (y < pad) y = pad;
        if (y + r.height > window.innerHeight - pad) y = window.innerHeight - r.height - pad;
        tipEl.style.left = x + 'px';
        tipEl.style.top = y + 'px';
    }

    if (!FIG || !FIG.data) return;

    // 1. Calculate the 'Max Envelope' of all visible traces
    const xLen = FIG.data[0].x.length;
    const maxY = new Array(xLen).fill(0);

    FIG.data.forEach(t => {
        // Remove existing fills from all real traces
        delete t.fill;
        delete t.fillcolor;

        // Calculate max y
        if (t.y && t.y.length === xLen) {
            t.y.forEach((val, i) => {
                const v = val || 0;
                if (v > maxY[i]) maxY[i] = v;
            });
        }
    });

    // 2. Create the envelope trace
    const envelopeTrace = {
        x: FIG.data[0].x,
        y: maxY,
        mode: 'lines',
        line: { width: 0, shape: 'spline', smoothing: 1.2 },
        fill: 'tozeroy', // This triggers the CSS gradient
        fillcolor: 'rgba(0,0,0,0)', // CSS overrides this
        hoverinfo: 'skip',
        showlegend: false,
        type: 'scatter',
        name: 'GradientBackground'
    };

    // 3. Add to the START of the array so it's DOM-first (for CSS :first-of-type)
    FIG.data.unshift(envelopeTrace);

    // 4. Add auxiliary traces (SpikeLine and HoverDots) to the END
    const spikeTrace = {
        x: [],
        y: [],
        mode: 'lines',
        line: { color: 'rgba(255, 255, 255, 0.7)', width: 1, dash: 'dash' },
        hoverinfo: 'skip',
        showlegend: false,
        name: 'SpikeLine',
        type: 'scatter'
    };

    const dotTrace = {
        x: [],
        y: [],
        mode: 'markers',
        marker: { size: 6, line: { color: 'white', width: 1 } },
        hoverinfo: 'skip',
        showlegend: false,
        name: 'HoverDots',
        type: 'scatter'
    };

    FIG.data.push(spikeTrace);
    FIG.data.push(dotTrace);

    Plotly.newPlot(chartEl, FIG.data, FIG.layout, config).then(gd => {
        // Hide default hover effects (points and labels) to prevent "double dots"
        try {
            const hoverlayer = gd.querySelector('.hoverlayer');
            if (hoverlayer) {
                hoverlayer.style.display = 'none';
            }
        } catch (e) { }

        // Dynamic Envelope Update Logic
        const updateEnvelope = () => {
            // Filter valid traces to consider for the envelope
            const visibleTraces = gd.data.filter(t =>
                t.name !== 'GradientBackground' &&
                t.name !== 'SpikeLine' &&
                t.name !== 'HoverDots' &&
                t.visible !== 'legendonly'
            );

            if (!visibleTraces.length || !gd.data[0].x) {
                // No visible traces, zero out envelope
                Plotly.restyle(gd, { y: [[]] }, [0]);
                return;
            }

            const xLen = gd.data[0].x.length;
            const maxY = new Array(xLen).fill(0);

            visibleTraces.forEach(t => {
                if (t.y && t.y.length === xLen) {
                    t.y.forEach((val, i) => {
                        if (val !== null && val !== undefined && val > maxY[i]) {
                            maxY[i] = val;
                        }
                    });
                }
            });

            // Update the envelope trace (index 0)
            Plotly.restyle(gd, { y: [maxY] }, [0]);
        };

        gd.on('plotly_restyle', (data) => {
            // data is [update, indices]
            const indices = data[1];
            if (indices && indices.includes(0)) return;
            updateEnvelope();
        });

        gd.on('plotly_hover', e => {
            const pt = e.points && e.points[0];
            if (!pt) return;
            const dateISO = (pt.x instanceof Date) ? pt.x.toISOString().slice(0, 10) : String(pt.x).slice(0, 10);

            const visibleAreas = [];
            gd.data.forEach(t => {
                if ((t.visible === undefined || t.visible === true) && t.name !== 'GradientBackground' && t.name !== 'HoverDots' && t.name !== 'SpikeLine') {
                    visibleAreas.push(t.name);
                }
            });

            const hovered = pt.data.name;
            const order = [];
            if (visibleAreas.includes(hovered)) order.push(hovered);
            if (!order.includes(LOOKUP.hero) && visibleAreas.includes(LOOKUP.hero)) order.push(LOOKUP.hero);
            visibleAreas.forEach(a => { if (!order.includes(a)) order.push(a); });

            tipEl.innerHTML = buildTooltipHTML(dateISO, order);
            tipEl.style.display = 'block';
            positionTooltip(e.event || window.event);

            // Update traces (SpikeLine and HoverDots) logic
            const idx = pt.pointIndex;
            const xVal = pt.x;

            // Update SpikeLine (2nd to last trace)
            const spikeTraceIdx = gd.data.length - 2;
            // Use a large Y range to cover the viewport dynamically
            Plotly.restyle(gd, {
                x: [[xVal, xVal]],
                y: [[-1000, 5000]]
            }, [spikeTraceIdx]);

            // Update HoverDots on top
            const yVals = [];
            const colors = [];
            gd.data.forEach(t => {
                if ((t.visible === undefined || t.visible === true) && t.name !== 'GradientBackground' && t.name !== 'HoverDots' && t.name !== 'SpikeLine' && t.y[idx] !== undefined) {
                    yVals.push(t.y[idx]);
                    colors.push(t.line.color);
                }
            });
            const xVals = new Array(yVals.length).fill(xVal);
            const dotTraceIdx = gd.data.length - 1;
            Plotly.restyle(gd, {
                x: [xVals],
                y: [yVals],
                'marker.color': [colors]
            }, [dotTraceIdx]);
        });

        gd.on('plotly_unhover', () => {
            tipEl.style.display = 'none';
            const spikeTraceIdx = gd.data.length - 2;
            const dotTraceIdx = gd.data.length - 1;
            Plotly.restyle(gd, { x: [[], []], y: [[], []] }, [spikeTraceIdx, dotTraceIdx]);
        });
        gd.addEventListener('mousemove', evt => { if (tipEl.style.display === 'block') positionTooltip(evt); });

        // Dual Range Slider Logic
        const yRangeMin = document.getElementById('yRangeMin');
        const yRangeMax = document.getElementById('yRangeMax');
        const xRangeMin = document.getElementById('xRangeMin');
        const xRangeMax = document.getElementById('xRangeMax');
        const yTrack = document.querySelector('.y-range-slider .track');
        const xTrack = document.querySelector('.x-range-slider .track');

        const ySliderContainer = document.querySelector('.y-slider-container');
        const updateYSliderWidth = () => {
            if (ySliderContainer) {
                const height = ySliderContainer.getBoundingClientRect().height;
                if (yRangeMin) yRangeMin.style.width = height + 'px';
                if (yRangeMax) yRangeMax.style.width = height + 'px';
            }
        };

        const ro = new ResizeObserver(() => {
            Plotly.Plots.resize(gd);
            updateYSliderWidth();
        });
        ro.observe(chartEl.parentElement);
        updateYSliderWidth();

        function updateYTrack() {
            let min = parseFloat(yRangeMin.value);
            let max = parseFloat(yRangeMax.value);

            if (min > max - 5) {
                yRangeMin.value = max - 5;
                min = max - 5;
            }
            if (max < min + 5) {
                yRangeMax.value = min + 5;
                max = min + 5;
            }

            const percentMin = ((min - 50) / (300 - 50)) * 100;
            const percentMax = ((max - 50) / (300 - 50)) * 100;

            yTrack.style.bottom = percentMin + '%';
            yTrack.style.height = (percentMax - percentMin) + '%';

            Plotly.relayout(gd, {
                'yaxis.range': [min, max]
            });
        }

        function updateXTrack() {
            let min = parseInt(xRangeMin.value);
            let max = parseInt(xRangeMax.value);

            if (min > max - 1) {
                xRangeMin.value = max - 1;
                min = max - 1;
            }
            if (max < min + 1) {
                xRangeMax.value = min + 1;
                max = min + 1;
            }

            const percentMin = (min / 91) * 100;
            const percentMax = (max / 91) * 100;

            xTrack.style.left = percentMin + '%';
            xTrack.style.width = (percentMax - percentMin) + '%';

            // Update slider attributes manually just in case
            if (xRangeMin.getAttribute('max') != String(dates.length - 1)) {
                xRangeMin.setAttribute('max', dates.length - 1);
                xRangeMax.setAttribute('max', dates.length - 1);
            }

            const startDate = LOOKUP.dates[min];
            const endDate = LOOKUP.dates[max];

            if (startDate && endDate) {
                Plotly.relayout(gd, {
                    'xaxis.range': [startDate, endDate]
                });
            }
        }

        yRangeMin.addEventListener('input', updateYTrack);
        yRangeMax.addEventListener('input', updateYTrack);
        xRangeMin.addEventListener('input', updateXTrack);
        xRangeMax.addEventListener('input', updateXTrack);

        updateYTrack();
        updateXTrack();
    });
})
    .catch(err => console.error("Error loading resources:", err));
    }

    // Start initialization
    initChart();
  </script>
</body>

</html>