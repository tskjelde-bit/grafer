<!doctype html>
<html lang="no">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Boligprisindeks – Oslo</title>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <style>
    :root {
      --bg: #0f1114;
      --text: rgba(255, 255, 255, 0.92);
      --muted: rgba(255, 255, 255, 0.60);
      --grid: rgba(255, 255, 255, 0.07);
    }

    html,
    body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .wrap {
      max-width: 1200px;
      margin: 20px auto;
      padding: 6px;
    }

    #chart {
      width: 100%;
      aspect-ratio: 4 / 3;
    }

    /* Tooltip */
    .mi-tooltip {
      position: fixed;
      display: none;
      z-index: 9999;
      background: rgba(16, 18, 22, 0.94);
      color: rgba(255, 255, 255, 0.94);
      border-radius: 12px;
      box-shadow: 0 28px 80px rgba(0, 0, 0, 0.65);
      padding: 14px;
      width: 360px;
      max-width: calc(100vw - 24px);
      max-height: min(560px, calc(100vh - 24px));
      overflow: auto;
      pointer-events: none;
    }

    .mi-tooltip::after {
      content: "";
      position: absolute;
      top: 22px;
      right: -10px;
      left: auto;
      border-top: 10px solid transparent;
      border-bottom: 10px solid transparent;
      border-left: 10px solid rgba(16, 18, 22, 0.94);
      border-right: none;
    }

    .mi-tooltip.flipped::after {
      right: auto;
      left: -10px;
      border-left: none;
      border-right: 10px solid rgba(16, 18, 22, 0.94);
    }

    .mi-tooltip .date {
      font-size: 18px;
      font-weight: 800;
      margin-bottom: 10px;
    }

    .mi-tooltip .rows {
      display: grid;
      grid-template-columns: 12px 1fr auto;
      gap: 8px 10px;
      font-size: 14px;
    }

    .mi-tooltip .label.hero {
      font-weight: 900;
    }

    /* Dual Range Sliders Removed */
    .chart-wrapper {
      position: relative;
      width: 100%;
      aspect-ratio: 4 / 3;
    }

    @media (max-width: 640px) {
      #chart {
        height: 600px;
      }

      .mi-tooltip {
        width: 300px;

      }
    }

    .trace.scatter:first-of-type path.js-fill {
      fill: url(#blueGradient) !important;
      fill-opacity: 1 !important;
    }

    /* Header */
    .chart-header {
      font-size: 1.6rem;
      font-weight: 600;
      margin: 0 0 10px 0;
      color: rgba(255, 255, 255, 0.92);
      letter-spacing: -0.02em;
    }

    .chart-subheader {
      font-size: 1.25rem;
      line-height: 1.2;
      font-weight: normal;
      color: var(--muted);
      margin: 0 0 20px 0;
    }

    /* Dropdown Controls */
    .controls-header {
      display: flex;
      justify-content: flex-start;
      margin-bottom: 10px;
      position: relative;
      z-index: 1000;
    }

    .custom-dropdown {
      position: relative;
      width: 220px;
      font-family: inherit;
    }

    .dropdown-btn {
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: var(--text);
      padding: 10px 14px;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.2s ease;
      font-size: 14px;
      font-weight: 500;
      user-select: none;
    }

    .dropdown-btn:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .dropdown-btn .chevron {
      font-size: 10px;
      opacity: 0.7;
      transition: transform 0.2s;
    }

    .dropdown-btn.open .chevron {
      transform: rotate(180deg);
    }

    .dropdown-content {
      display: none;
      position: absolute;
      top: calc(100% + 8px);
      left: 0;
      width: 260px;
      max-height: 400px;
      overflow-y: auto;
      background: #16181d;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      padding: 6px;
      z-index: 1001;
    }

    .dropdown-content.show {
      display: block;
    }

    .dropdown-item {
      padding: 8px 10px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
      transition: background 0.15s;
      font-size: 13px;
      color: var(--muted);
      user-select: none;
    }

    .dropdown-item:hover {
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
    }

    .dropdown-item input[type="checkbox"] {
      appearance: none;
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      background: transparent;
      cursor: pointer;
      position: relative;
      flex-shrink: 0;
      transition: all 0.2s;
    }

    .dropdown-item input[type="checkbox"]:checked {
      background: #1E88FF;
      border-color: #1E88FF;
    }

    .dropdown-item input[type="checkbox"]:checked::after {
      content: '';
      position: absolute;
      left: 5px;
      top: 2px;
      width: 4px;
      height: 8px;
      border: solid white;
      border-width: 0 2px 2px 0;
      transform: rotate(45deg);
    }

    .color-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    /* Scrollbar */
    .dropdown-content::-webkit-scrollbar {
      width: 6px;
    }

    .dropdown-content::-webkit-scrollbar-track {
      background: transparent;
    }

    .dropdown-content::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
    }

    .dropdown-content::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.2);
    }
  </style>

</head>

<body>
  <svg width="0" height="0" style="position: absolute; pointer-events: none;">
    <defs>
      <linearGradient id="blueGradient" x1="0" x2="0" y1="0" y2="1">
        <stop offset="0%" stop-color="#1E88FF" stop-opacity="0.25" />
        <stop offset="80%" stop-color="#1E88FF" stop-opacity="0" />
      </linearGradient>
    </defs>
  </svg>
  <div class="wrap">

    <h1 class="chart-header">Boligprisindeks – Oslo</h1>
    <div class="chart-subheader">Utforsk prisutviklingen i Oslos bydeler over tid</div>

    <!-- Legend Dropdown -->
    <div class="controls-header">
      <div class="custom-dropdown" id="areaDropdown">
        <div class="dropdown-btn" id="dropdownBtn">
          <span>Velg bydeler</span>
          <span class="chevron">▼</span>
        </div>
        <div class="dropdown-content" id="dropdownList">
          <!-- Populated by JS -->
        </div>
      </div>
    </div>

    <div class="chart-wrapper">
      <div id="chart"></div>
    </div>
  </div>
  <div id="miTooltip" class="mi-tooltip"></div>

  <script>
    // Async Plotly loading wrapper
    function initChart() {
      if (typeof Plotly === 'undefined') {
        console.log('Plotly not loaded yet, retrying...');
        setTimeout(initChart, 50);
        return;
      }

      console.log('Plotly loaded, initializing chart...');


      // --- CONFIG ---
      Promise.all([
        fetch('data.csv').then(r => r.text()),
        fetch('layout.json').then(r => r.json()),
        fetch('config.json').then(r => r.json())
      ]).then(([csvText, layoutJson, configJson]) => {

        const AREA_COLORS = configJson.colors;
        const HERO = configJson.hero;

        // Parse CSV
        const lines = csvText.trim().split('\n');
        const headers = lines[0].split(',');
        const areaNames = headers.slice(1);

        const dates = [];
        const areaValues = {};
        areaNames.forEach(a => areaValues[a] = []);

        for (let i = 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;
          const cols = line.split(',');
          dates.push(cols[0]);
          for (let j = 1; j < cols.length; j++) {
            const val = cols[j] === '' ? null : parseFloat(cols[j]);
            areaValues[areaNames[j - 1]].push(val);
          }
        }

        // Build Traces
        const traces = [];
        areaNames.forEach(name => {
          const isHero = name === HERO;
          const trace = {
            x: dates,
            y: areaValues[name],
            type: 'scatter',
            mode: 'lines',
            name: name,
            line: {
              color: AREA_COLORS[name] || '#999',
              shape: 'spline',
              smoothing: 1.2,
              width: isHero ? 3.5 : 2.4
            },
            opacity: isHero ? 1.0 : 0.85,
            hoverinfo: 'none',
            hovertemplate: '<extra></extra>'
          };
          if (isHero) {
            trace.fill = 'tozeroy';
            trace.fillcolor = 'rgba(30,136,255,0.14)';
          }
          traces.push(trace);
        });

        // Re-assemble objects
        const FIG = {
          data: traces,
          layout: layoutJson
        };
        FIG.layout.showlegend = false;
        // Move title to HTML so we can place dropdown under it
        if (FIG.layout.title) FIG.layout.title = undefined;

        const LOOKUP = {
          dates: dates,
          areas: areaNames,
          values: areaValues,
          colors: AREA_COLORS,
          hero: HERO
        };

        const chartEl = document.getElementById('chart');
        const tipEl = document.getElementById('miTooltip');
        // check if elements exist
        if (!chartEl || !tipEl) return;

        const config = {
          responsive: true,
          displaylogo: false,
          displayModeBar: false,
          modeBarButtonsToRemove: ['select2d', 'lasso2d'],
        };

        // Add bottom margin to layout
        FIG.layout.margin.b = 160;

        function formatDateISOToNO(iso) {
          const [y, m, d] = iso.split('-');
          return `${d}.${m}.${y}`;
        }
        function formatNumberNO(x) {
          if (x === null || x === undefined || Number.isNaN(x)) return '';
          return x.toFixed(2).replace('.', ',');
        }

        const dateIndex = Object.create(null);
        LOOKUP.dates.forEach((d, i) => dateIndex[d] = i);

        function buildTooltipHTML(dateISO, orderAreas) {
          const idx = dateIndex[dateISO];
          let rows = '';
          for (const area of orderAreas) {
            const v = idx !== undefined ? LOOKUP.values[area][idx] : null;
            rows += `
          <div class="dot" style="background:${LOOKUP.colors[area]}"></div>
          <div class="label ${area === LOOKUP.hero ? 'hero' : ''}">${area}</div>
          <div class="val">${formatNumberNO(v)}</div>
        `;
          }
          return `<div class="date">${formatDateISOToNO(dateISO)}</div><div class="rows">${rows}</div>`;
        }

        function positionTooltip(evt) {
          const r = tipEl.getBoundingClientRect();
          const pad = 10;
          let x, y;

          // Check if cursor is on the left half of the screen
          if (evt.clientX < window.innerWidth / 2) {
            // Place tooltip to the RIGHT of cursor
            x = evt.clientX + 18;
            tipEl.classList.add('flipped');
          } else {
            // Place tooltip to the LEFT of cursor
            x = evt.clientX - r.width - 18;
            tipEl.classList.remove('flipped');
          }

          y = evt.clientY - 26;

          // Boundary checks
          if (x < pad) x = pad;
          if (x + r.width > window.innerWidth - pad) x = window.innerWidth - r.width - pad;

          if (y < pad) y = pad;
          if (y + r.height > window.innerHeight - pad) y = window.innerHeight - r.height - pad;

          tipEl.style.left = x + 'px';
          tipEl.style.top = y + 'px';
        }

        if (!FIG || !FIG.data) return;

        // 1. Calculate the 'Max Envelope' of all visible traces
        const xLen = FIG.data[0].x.length;
        const maxY = new Array(xLen).fill(0);

        FIG.data.forEach(t => {
          // Remove existing fills from all real traces
          delete t.fill;
          delete t.fillcolor;

          // Calculate max y
          if (t.y && t.y.length === xLen) {
            t.y.forEach((val, i) => {
              const v = val || 0;
              if (v > maxY[i]) maxY[i] = v;
            });
          }
        });

        // 2. Create the envelope trace
        const envelopeTrace = {
          x: FIG.data[0].x,
          y: maxY,
          mode: 'lines',
          line: { width: 0, shape: 'spline', smoothing: 1.2 },
          fill: 'tozeroy', // This triggers the CSS gradient
          fillcolor: 'rgba(0,0,0,0)', // CSS overrides this
          hoverinfo: 'skip',
          showlegend: false,
          type: 'scatter',
          name: 'GradientBackground'
        };

        // 3. Add to the START of the array so it's DOM-first (for CSS :first-of-type)
        FIG.data.unshift(envelopeTrace);

        // 4. Add auxiliary traces (HoverDots) to the END
        // Note: SpikeLine removed in favor of layout shapes to prevent axis jitter

        const dotTrace = {
          x: [],
          y: [],
          mode: 'markers',
          marker: { size: 6, line: { color: 'white', width: 1 } },
          hoverinfo: 'skip',
          showlegend: false,
          name: 'HoverDots',
          type: 'scatter'
        };

        FIG.data.push(dotTrace);

        // Ensure shapes array exists and add our SpikeLine shape
        if (!FIG.layout.shapes) FIG.layout.shapes = [];
        FIG.layout.shapes.push({
          type: 'line',
          xref: 'x',
          yref: 'paper',
          x0: 0,
          y0: 0,
          x1: 0,
          y1: 1,
          line: {
            color: 'rgba(255, 255, 255, 0.7)',
            width: 1,
            dash: 'dash'
          },
          visible: false
        });
        // We need to know the index of our shape. Since we pushed it last:
        const spikeShapeIdx = FIG.layout.shapes.length - 1;

        Plotly.newPlot(chartEl, FIG.data, FIG.layout, config).then(gd => {
          // Hide default hover effects (points and labels) to prevent "double dots"
          try {
            const hoverlayer = gd.querySelector('.hoverlayer');
            if (hoverlayer) {
              hoverlayer.style.display = 'none';
            }
          } catch (e) { }

          // Lock axis ranges to prevent "breathing" / shifting when hovering near edges or adding dots
          try {
            const xr = gd._fullLayout.xaxis.range;
            const yr = gd._fullLayout.yaxis.range;
            Plotly.relayout(gd, {
              'xaxis.range': [xr[0], xr[1]],
              'yaxis.range': [yr[0], yr[1]],
              'xaxis.autorange': false,
              'yaxis.autorange': false
            });
          } catch (e) { console.error('Error locking axes:', e); }

          // Dynamic Envelope Update Logic
          const updateEnvelope = () => {
            // Filter valid traces to consider for the envelope
            const visibleTraces = gd.data.filter(t =>
              t.name !== 'GradientBackground' &&
              t.name !== 'SpikeLine' &&
              t.name !== 'HoverDots' &&
              t.visible !== 'legendonly' &&
              t.visible !== false
            );

            if (!visibleTraces.length || !gd.data[0].x) {
              // No visible traces, zero out envelope
              Plotly.restyle(gd, { y: [[]] }, [0]);
              return;
            }

            const xLen = gd.data[0].x.length;
            const maxY = new Array(xLen).fill(0);

            visibleTraces.forEach(t => {
              if (t.y && t.y.length === xLen) {
                t.y.forEach((val, i) => {
                  if (val !== null && val !== undefined && val > maxY[i]) {
                    maxY[i] = val;
                  }
                });
              }
            });

            // Update the envelope trace (index 0)
            Plotly.restyle(gd, { y: [maxY] }, [0]);
          };

          gd.on('plotly_restyle', (data) => {
            // data is [update, indices]
            const indices = data[1];
            if (indices && indices.includes(0)) return;
            updateEnvelope();
          });

          gd.on('plotly_hover', e => {
            const pt = e.points && e.points[0];
            if (!pt) return;
            const dateISO = (pt.x instanceof Date) ? pt.x.toISOString().slice(0, 10) : String(pt.x).slice(0, 10);

            const visibleAreas = [];
            gd.data.forEach(t => {
              if ((t.visible === undefined || t.visible === true) && t.name !== 'GradientBackground' && t.name !== 'HoverDots' && t.name !== 'SpikeLine') {
                visibleAreas.push(t.name);
              }
            });

            const hovered = pt.data.name;
            const order = [];
            if (visibleAreas.includes(hovered)) order.push(hovered);
            if (!order.includes(LOOKUP.hero) && visibleAreas.includes(LOOKUP.hero)) order.push(LOOKUP.hero);
            visibleAreas.forEach(a => { if (!order.includes(a)) order.push(a); });

            tipEl.innerHTML = buildTooltipHTML(dateISO, order);
            tipEl.style.display = 'block';
            positionTooltip(e.event || window.event);

            // Update traces (SpikeLine and HoverDots) logic
            const idx = pt.pointIndex;
            const xVal = pt.x;

            // Update SpikeLine (Shape)
            // Using relayout on a shape with yref='paper' prevents any axis auto-scaling issues
            const update = {};
            update[`shapes[${spikeShapeIdx}].x0`] = xVal;
            update[`shapes[${spikeShapeIdx}].x1`] = xVal;
            update[`shapes[${spikeShapeIdx}].visible`] = true;
            Plotly.relayout(gd, update);

            // Update HoverDots on top
            const yVals = [];
            const colors = [];
            gd.data.forEach(t => {
              if ((t.visible === undefined || t.visible === true) && t.name !== 'GradientBackground' && t.name !== 'HoverDots' && t.name !== 'SpikeLine' && t.y[idx] !== undefined) {
                yVals.push(t.y[idx]);
                colors.push(t.line.color);
              }
            });
            const xVals = new Array(yVals.length).fill(xVal);
            const dotTraceIdx = gd.data.length - 1;
            Plotly.restyle(gd, {
              x: [xVals],
              y: [yVals],
              'marker.color': [colors]
            }, [dotTraceIdx]);
          });

          gd.on('plotly_unhover', () => {
            tipEl.style.display = 'none';
            // Hide spike line shape
            const update = {};
            update[`shapes[${spikeShapeIdx}].visible`] = false;
            Plotly.relayout(gd, update);

            // Clear dots
            const dotTraceIdx = gd.data.length - 1;
            Plotly.restyle(gd, { x: [[]], y: [[]] }, [dotTraceIdx]);
          });
          gd.addEventListener('mousemove', evt => { if (tipEl.style.display === 'block') positionTooltip(evt); });

          const ro = new ResizeObserver(() => {
            Plotly.Plots.resize(gd);
          });
          ro.observe(chartEl.parentElement);

          // --- Dropdown Logic ---
          const dropdownBtn = document.getElementById('dropdownBtn');
          const dropdownList = document.getElementById('dropdownList');
          const dropdownWrapper = document.getElementById('areaDropdown');

          // Toggle dropdown
          dropdownBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            dropdownList.classList.toggle('show');
            dropdownBtn.classList.toggle('open');
          });

          // Close when clicking outside
          document.addEventListener('click', (e) => {
            if (!dropdownWrapper.contains(e.target)) {
              dropdownList.classList.remove('show');
              dropdownBtn.classList.remove('open');
            }
          });

          // Populate Dropdown
          // Add "Velg alle" option
          const allItem = document.createElement('div');
          allItem.className = 'dropdown-item';
          allItem.innerHTML = `
            <input type="checkbox" checked id="cb-all">
            <span style="font-weight:600">Velg alle</span>
        `;
          dropdownList.appendChild(allItem);
          const cbAll = allItem.querySelector('input');

          // Area items
          areaNames.forEach(area => {
            const color = AREA_COLORS[area] || '#999';
            const item = document.createElement('div');
            item.className = 'dropdown-item';
            // Prevent label click from double-triggering checkbox if we nested, 
            // but here we just catch item click
            item.innerHTML = `
                <input type="checkbox" checked value="${area}" class="area-cb">
                <div class="color-dot" style="background:${color}"></div>
                <span>${area}</span>
            `;
            dropdownList.appendChild(item);
          });

          // Handle Checkbox Changes
          const checkboxes = dropdownList.querySelectorAll('.area-cb');

          function updatePlot() {
            const checkedAreas = [];
            checkboxes.forEach(cb => {
              if (cb.checked) checkedAreas.push(cb.value);
            });

            // Update Plotly visibility
            // We need to map traces to visibility. 
            // Note: trace names match areaNames.
            // Also need to handle auxiliary traces (keep them hidden/skip).

            const updateVisibility = [];
            const updateIndices = [];

            gd.data.forEach((t, i) => {
              const name = t.name;
              // Skip aux traces
              if (name === 'GradientBackground' || name === 'SpikeLine' || name === 'HoverDots') return;

              const shouldBeVisible = checkedAreas.includes(name);
              // "visible" property: true, false, or "legendonly".
              // We use true/false here effectively.
              const currentState = (t.visible === undefined || t.visible === true);

              if (currentState !== shouldBeVisible) {
                updateVisibility.push(shouldBeVisible ? true : false);
                updateIndices.push(i);
              }
            });

            if (updateIndices.length > 0) {
              Plotly.restyle(gd, { visible: updateVisibility }, updateIndices);
            }

            // Update "All" checkbox state
            const allChecked = checkedAreas.length === checkboxes.length;
            cbAll.checked = allChecked;
            cbAll.indeterminate = checkedAreas.length > 0 && !allChecked;

            // Update button text
            if (allChecked) {
              dropdownBtn.querySelector('span').textContent = 'Alle bydeler';
            } else if (checkedAreas.length === 0) {
              dropdownBtn.querySelector('span').textContent = 'Ingen valgt';
            } else {
              dropdownBtn.querySelector('span').textContent = `${checkedAreas.length} valgt`;
            }
          }

          // Event Listeners for Items
          dropdownList.querySelectorAll('.dropdown-item').forEach(item => {
            item.addEventListener('click', (e) => {
              // If clicked on input, let it toggle naturaly, just update plot
              // If clicked on div, toggle input then update plot
              const cb = item.querySelector('input');
              if (e.target !== cb) {
                cb.checked = !cb.checked;
              }

              if (cb === cbAll) {
                // Toggle all
                const state = cb.checked;
                checkboxes.forEach(c => c.checked = state);
              } else {
                // Check if all are now checked
                const all = Array.from(checkboxes).every(c => c.checked);
                cbAll.checked = all;
                cbAll.indeterminate = !all && Array.from(checkboxes).some(c => c.checked);
              }

              updatePlot();
            });
          });

          // Initialize button text
          dropdownBtn.querySelector('span').textContent = 'Alle bydeler';

        });
      })
        .catch(err => console.error("Error loading resources:", err));
    }

    // Start initialization
    initChart();
  </script>
</body>

</html>