<!doctype html>
<html lang="no">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Boligmarked siste 12 måneder – Oslo</title>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <style>
    :root {
      --bg: #0f1114;
      --text: rgba(255, 255, 255, 0.92);
      --muted: rgba(255, 255, 255, 0.60);
      --grid: rgba(255, 255, 255, 0.07);
    }

    html,
    body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .wrap {
      max-width: 1200px;
      margin: 20px auto;
      padding: 6px;
    }

    #chart {
      width: 100%;
      aspect-ratio: 4 / 3;
    }

    /* Tooltip */
    .mi-tooltip {
      position: fixed;
      display: none;
      z-index: 9999;
      background: rgba(16, 18, 22, 0.94);
      color: rgba(255, 255, 255, 0.94);
      border-radius: 12px;
      box-shadow: 0 28px 80px rgba(0, 0, 0, 0.65);
      padding: 14px;
      width: 220px;
      max-width: calc(100vw - 24px);
      max-height: min(560px, calc(100vh - 24px));
      overflow: auto;
      pointer-events: none;
    }

    .mi-tooltip::after {
      content: "";
      position: absolute;
      top: 22px;
      right: -10px;
      left: auto;
      border-top: 10px solid transparent;
      border-bottom: 10px solid transparent;
      border-left: 10px solid rgba(16, 18, 22, 0.94);
      border-right: none;
    }

    .mi-tooltip.flipped::after {
      right: auto;
      left: -10px;
      border-left: none;
      border-right: 10px solid rgba(16, 18, 22, 0.94);
    }

    .mi-tooltip .date {
      font-size: 18px;
      font-weight: 800;
      margin-bottom: 10px;
    }

    .mi-tooltip .rows {
      display: grid;
      grid-template-columns: 12px 1fr auto;
      gap: 8px 10px;
      font-size: 14px;
    }

    .mi-tooltip .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-top: 3px;
    }

    .chart-wrapper {
      position: relative;
      width: 100%;
      aspect-ratio: 4 / 3;
    }

    @media (max-width: 640px) {
      #chart {
        height: 500px;
      }

      .mi-tooltip {
        width: 200px;
      }
    }

    /* Header */
    .chart-header {
      font-size: 1.25rem;
      font-weight: 600;
      margin: 0 0 10px 0;
      color: var(--text);
      letter-spacing: -0.02em;
    }

    .chart-subheader {
      font-size: 1.1rem;
      line-height: 1.2;
      font-weight: normal;
      color: var(--muted);
      margin: 0 0 20px 0;
    }

    /* Legend */
    .legend-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 16px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      color: var(--muted);
      cursor: pointer;
      user-select: none;
      transition: opacity 0.2s;
    }

    .legend-item:hover {
      color: var(--text);
    }

    .legend-item.disabled {
      opacity: 0.4;
    }

    .legend-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .legend-line {
      width: 24px;
      height: 3px;
      border-radius: 2px;
    }

    /* Gradient fills for area under lines */
    .trace.scatter:nth-of-type(1) path.js-fill {
      fill: url(#orangeGradient) !important;
      fill-opacity: 1 !important;
    }
    .trace.scatter:nth-of-type(2) path.js-fill {
      fill: url(#blueGradient) !important;
      fill-opacity: 1 !important;
    }
  </style>
</head>

<body>
  <!-- SVG Gradient Definitions -->
  <svg width="0" height="0" style="position: absolute; pointer-events: none;">
    <defs>
      <linearGradient id="blueGradient" x1="0" x2="0" y1="0" y2="1">
        <stop offset="0%" stop-color="#4FAEF6" stop-opacity="0.35" />
        <stop offset="80%" stop-color="#4FAEF6" stop-opacity="0" />
      </linearGradient>
      <linearGradient id="orangeGradient" x1="0" x2="0" y1="0" y2="1">
        <stop offset="0%" stop-color="#F2A541" stop-opacity="0.25" />
        <stop offset="80%" stop-color="#F2A541" stop-opacity="0" />
      </linearGradient>
    </defs>
  </svg>

  <div class="wrap">
    <h1 class="chart-header">Boligmarked siste 12 måneder</h1>
    <div class="chart-subheader" id="chartSubheader">Antall boliger solgt og lagt ut for salg i Oslo</div>

    <div class="legend-container" id="legendContainer"></div>

    <div class="chart-wrapper">
      <div id="chart"></div>
    </div>
  </div>
  <div id="miTooltip" class="mi-tooltip"></div>

  <script>
    // URL parameters handling
    const urlParams = new URLSearchParams(window.location.search);
    const themeParam = urlParams.get('theme');
    const aspectParam = urlParams.get('aspect');
    const isTransparent = urlParams.get('transparent') === '1';

    // Apply theme from URL parameter
    if (themeParam === 'light') {
      document.documentElement.style.setProperty('--bg', '#ffffff');
      document.documentElement.style.setProperty('--text', '#1a1a2e');
      document.documentElement.style.setProperty('--muted', '#6b7280');
      document.body.style.background = '#ffffff';
      document.body.style.color = '#1a1a2e';
    }

    // Apply aspect ratio from URL parameter (default 4:3)
    const aspectValue = aspectParam || '1.33';
    document.getElementById('chart').style.aspectRatio = aspectValue;
    document.querySelector('.chart-wrapper').style.aspectRatio = aspectValue;

    // Preview mode - only hide headers and legend if explicitly requested via URL
    if (window.location.search.includes('minimal=true')) {
      document.querySelector('.chart-header')?.style.setProperty('display', 'none');
      document.querySelector('.chart-subheader')?.style.setProperty('display', 'none');
      document.querySelector('.legend-container')?.style.setProperty('display', 'none');
      document.querySelector('.wrap')?.style.setProperty('padding', '0');
      document.querySelector('.wrap')?.style.setProperty('margin', '0');
    }

    // Embed mode - no margins for iframes, inherit fonts
    if (window.self !== window.top) {
      document.querySelector('.wrap')?.style.setProperty('margin', '0');
      document.querySelector('.wrap')?.style.setProperty('padding', '0');
      document.querySelector('.wrap')?.style.setProperty('max-width', 'none');
      document.body.style.fontFamily = 'inherit';
    }

    // Apply transparent background if requested
    if (isTransparent) {
      document.documentElement.style.background = 'transparent';
      document.body.style.background = 'transparent';
      document.querySelector('.wrap').style.background = 'transparent';
      document.querySelector('.chart-wrapper').style.background = 'transparent';
    }
  </script>

  <script>
    function initChart() {
      if (typeof Plotly === 'undefined') {
        setTimeout(initChart, 50);
        return;
      }

      const monthOrder = ['jan', 'feb', 'mar', 'apr', 'mai', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'des'];
      const monthNames = {
        'jan': 'Januar', 'feb': 'Februar', 'mar': 'Mars', 'apr': 'April',
        'mai': 'Mai', 'jun': 'Juni', 'jul': 'Juli', 'aug': 'August',
        'sep': 'September', 'okt': 'Oktober', 'nov': 'November', 'des': 'Desember'
      };

      const urlParams = new URLSearchParams(window.location.search);
      const isLightTheme = urlParams.get('theme') === 'light';
      const isTransparent = urlParams.get('transparent') === '1';

      const colors = {
        solgt: '#4FAEF6',
        lagtUt: '#F2A541'
      };

      const bgColor = isTransparent ? 'rgba(0,0,0,0)' : (isLightTheme ? '#ffffff' : '#0f1114');
      const textColor = isLightTheme ? '#1a1a2e' : 'rgba(255,255,255,0.92)';
      const mutedColor = isLightTheme ? '#6b7280' : 'rgba(255,255,255,0.40)';
      const gridColor = isLightTheme ? 'rgba(0,0,0,0.06)' : 'rgba(255,255,255,0.04)';
      const lineColor = isLightTheme ? 'rgba(0,0,0,0.15)' : 'rgba(255,255,255,0.20)';

      // Fetch both data files
      Promise.all([
        fetch('../data_solgt.csv?t=' + Date.now()).then(r => r.text()),
        fetch('../data_lagt_ut.csv?t=' + Date.now()).then(r => r.text())
      ]).then(([solgtCsv, lagtUtCsv]) => {
        // Parse solgt data (format: month,value,year)
        const solgtData = {};
        const solgtLines = solgtCsv.trim().split('\n');
        for (let i = 1; i < solgtLines.length; i++) {
          const cols = solgtLines[i].split(',').map(c => c.trim());
          if (cols.length < 3) continue;
          const month = cols[0].toLowerCase();
          const value = parseInt(cols[1], 10);
          const year = cols[2].trim();
          const key = `${year}-${month}`;
          solgtData[key] = value;
        }

        // Parse lagt ut data (format: month,year,value)
        const lagtUtData = {};
        const lagtUtLines = lagtUtCsv.trim().split('\n');
        for (let i = 1; i < lagtUtLines.length; i++) {
          const cols = lagtUtLines[i].split(',').map(c => c.trim());
          if (cols.length < 3) continue;
          const month = cols[0].toLowerCase();
          const year = cols[1].trim();
          const value = parseInt(cols[2], 10);
          const key = `${year}-${month}`;
          lagtUtData[key] = value;
        }

        // Get all unique year-month combinations and sort them
        const allKeys = new Set([...Object.keys(solgtData), ...Object.keys(lagtUtData)]);
        const sortedKeys = Array.from(allKeys).sort((a, b) => {
          const [yearA, monthA] = a.split('-');
          const [yearB, monthB] = b.split('-');
          if (yearA !== yearB) return parseInt(yearA) - parseInt(yearB);
          return monthOrder.indexOf(monthA) - monthOrder.indexOf(monthB);
        });

        // Find the newest month from whichever dataset has the most recent data
        const newestKey = sortedKeys[sortedKeys.length - 1];
        const [newestYear, newestMonth] = newestKey.split('-');

        // Generate the last 12 months going backwards from the newest
        const last12 = [];
        let year = parseInt(newestYear);
        let monthIdx = monthOrder.indexOf(newestMonth);

        for (let i = 0; i < 12; i++) {
          const key = `${year}-${monthOrder[monthIdx]}`;
          last12.unshift(key); // Add to beginning to keep chronological order

          monthIdx--;
          if (monthIdx < 0) {
            monthIdx = 11;
            year--;
          }
        }

        // Build data arrays
        const dates = last12.map(key => {
          const [year, month] = key.split('-');
          return `${monthNames[month]} ${year}`;
        });

        const solgtValues = last12.map(key => solgtData[key] || null);
        const lagtUtValues = last12.map(key => lagtUtData[key] || null);

        // Store for tooltip
        const LOOKUP = {
          dates: dates,
          keys: last12,
          solgt: solgtValues,
          lagtUt: lagtUtValues
        };

        // Calculate totals and update subheader
        const totalSolgt = solgtValues.reduce((sum, val) => sum + (val || 0), 0);
        const totalLagtUt = lagtUtValues.reduce((sum, val) => sum + (val || 0), 0);
        const diff = totalLagtUt - totalSolgt;
        const subheaderEl = document.getElementById('chartSubheader');
        if (subheaderEl) {
          subheaderEl.textContent = `De siste 12 månedene er det solgt ${totalSolgt.toLocaleString('nb-NO')} og lagt ut for salg ${totalLagtUt.toLocaleString('nb-NO')} – Det er lagt ut ${diff.toLocaleString('nb-NO')} flere enn det er solgt`;
        }

        // Build envelope traces for gradient fills (rendered first, behind the lines)
        // Order: lagtUt envelope (back), solgt envelope (middle), lagtUt line, solgt line (front)
        const envelopeLagtUt = {
          x: dates,
          y: lagtUtValues,
          type: 'scatter',
          mode: 'none',
          name: 'Lagt ut fill',
          fill: 'tozeroy',
          fillcolor: 'rgba(242, 165, 65, 0.25)',
          line: { shape: 'spline', smoothing: 1.2 },
          hoverinfo: 'skip',
          showlegend: false
        };

        const envelopeSolgt = {
          x: dates,
          y: solgtValues,
          type: 'scatter',
          mode: 'none',
          name: 'Solgt fill',
          fill: 'tozeroy',
          fillcolor: 'rgba(79, 174, 246, 0.35)',
          line: { shape: 'spline', smoothing: 1.2 },
          hoverinfo: 'skip',
          showlegend: false
        };

        // Build line traces
        const traceLagtUt = {
          x: dates,
          y: lagtUtValues,
          type: 'scatter',
          mode: 'lines+markers',
          name: 'Lagt ut',
          line: {
            color: colors.lagtUt,
            width: 3,
            shape: 'spline',
            smoothing: 1.2
          },
          marker: {
            size: 8,
            color: colors.lagtUt
          },
          hoverinfo: 'none'
        };

        const traceSolgt = {
          x: dates,
          y: solgtValues,
          type: 'scatter',
          mode: 'lines+markers',
          name: 'Solgt',
          line: {
            color: colors.solgt,
            width: 3,
            shape: 'spline',
            smoothing: 1.2
          },
          marker: {
            size: 8,
            color: colors.solgt
          },
          hoverinfo: 'none'
        };

        // Order: envelopes first (back to front), then lines (back to front)
        const traces = [envelopeLagtUt, envelopeSolgt, traceLagtUt, traceSolgt];

        const layout = {
          paper_bgcolor: bgColor,
          plot_bgcolor: bgColor,
          font: {
            family: 'Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif',
            color: textColor,
            size: 14
          },
          margin: { l: 0, r: 20, t: 30, b: 80 },
          xaxis: {
            showgrid: false,
            showline: true,
            linecolor: lineColor,
            tickfont: { color: mutedColor, size: 11 },
            tickangle: -45,
            zeroline: false,
            ticks: '',
            tickcolor: lineColor,
            mirror: false
          },
          yaxis: {
            showgrid: true,
            gridcolor: gridColor,
            showline: true,
            linecolor: lineColor,
            tickfont: { color: mutedColor },
            zeroline: false,
            ticks: 'outside',
            ticklen: 8,
            tickcolor: 'rgba(0,0,0,0)',
            mirror: false,
            automargin: true
          },
          showlegend: false,
          hovermode: 'x unified'
        };

        const config = {
          responsive: true,
          displaylogo: false,
          displayModeBar: false
        };

        const chartEl = document.getElementById('chart');
        const tipEl = document.getElementById('miTooltip');
        const legendEl = document.getElementById('legendContainer');

        // Build legend
        // Trace order: [0: envelopeLagtUt, 1: envelopeSolgt, 2: traceLagtUt, 3: traceSolgt]
        const legendItems = [
          { name: 'Solgt', color: colors.solgt, lineIdx: 3, envIdx: 1 },
          { name: 'Lagt ut for salg', color: colors.lagtUt, lineIdx: 2, envIdx: 0 }
        ];

        const visibleTraces = new Set([0, 1, 2, 3]);

        legendItems.forEach(item => {
          const div = document.createElement('div');
          div.className = 'legend-item';
          div.dataset.lineIdx = item.lineIdx;
          div.dataset.envIdx = item.envIdx;
          div.innerHTML = `
            <div class="legend-line" style="background:${item.color}"></div>
            <span>${item.name}</span>
          `;
          legendEl.appendChild(div);
        });

        function formatNumberNO(x) {
          if (x === null || x === undefined || Number.isNaN(x)) return '-';
          return x.toLocaleString('nb-NO');
        }

        function buildTooltipHTML(idx) {
          const date = LOOKUP.dates[idx];
          let rows = '';

          // Solgt line is trace index 3
          if (visibleTraces.has(3)) {
            rows += `
              <div class="dot" style="background:${colors.solgt}"></div>
              <div class="label">Solgt</div>
              <div class="val">${formatNumberNO(LOOKUP.solgt[idx])}</div>
            `;
          }
          // Lagt ut line is trace index 2
          if (visibleTraces.has(2)) {
            rows += `
              <div class="dot" style="background:${colors.lagtUt}"></div>
              <div class="label">Lagt ut</div>
              <div class="val">${formatNumberNO(LOOKUP.lagtUt[idx])}</div>
            `;
          }
          return `<div class="date">${date}</div><div class="rows">${rows}</div>`;
        }

        function positionTooltip(evt) {
          const r = tipEl.getBoundingClientRect();
          const pad = 10;
          let x, y;

          if (evt.clientX < window.innerWidth / 2) {
            x = evt.clientX + 18;
            tipEl.classList.add('flipped');
          } else {
            x = evt.clientX - r.width - 18;
            tipEl.classList.remove('flipped');
          }

          y = evt.clientY - 26;

          if (x < pad) x = pad;
          if (x + r.width > window.innerWidth - pad) x = window.innerWidth - r.width - pad;
          if (y < pad) y = pad;
          if (y + r.height > window.innerHeight - pad) y = window.innerHeight - r.height - pad;

          tipEl.style.left = x + 'px';
          tipEl.style.top = y + 'px';
        }

        Plotly.newPlot(chartEl, traces, layout, config).then(gd => {
          // Hide default hover
          try {
            const hoverlayer = gd.querySelector('.hoverlayer');
            if (hoverlayer) hoverlayer.style.display = 'none';
          } catch (e) { }

          // Legend click handlers
          legendEl.querySelectorAll('.legend-item').forEach(item => {
            item.addEventListener('click', () => {
              const lineIdx = parseInt(item.dataset.lineIdx);
              const envIdx = parseInt(item.dataset.envIdx);
              if (visibleTraces.has(lineIdx)) {
                visibleTraces.delete(lineIdx);
                visibleTraces.delete(envIdx);
                item.classList.add('disabled');
                Plotly.restyle(gd, { visible: false }, [lineIdx, envIdx]);
              } else {
                visibleTraces.add(lineIdx);
                visibleTraces.add(envIdx);
                item.classList.remove('disabled');
                Plotly.restyle(gd, { visible: true }, [lineIdx, envIdx]);
              }
            });
          });

          gd.on('plotly_hover', e => {
            const pt = e.points && e.points[0];
            if (!pt) return;
            const idx = pt.pointIndex;

            tipEl.innerHTML = buildTooltipHTML(idx);
            tipEl.style.display = 'block';
            positionTooltip(e.event || window.event);
          });

          gd.on('plotly_unhover', () => {
            tipEl.style.display = 'none';
          });

          gd.addEventListener('mousemove', evt => {
            if (tipEl.style.display === 'block') positionTooltip(evt);
          });

          const ro = new ResizeObserver(() => {
            Plotly.Plots.resize(gd);
          });
          ro.observe(chartEl.parentElement);
        });
      }).catch(err => console.error("Error loading data:", err));
    }

    initChart();

    // Send height to parent for embed auto-resize
    function sendHeight() {
      if (window.self !== window.top) {
        const wrap = document.querySelector('.wrap');
        const height = Math.max(
          document.body.scrollHeight,
          document.body.offsetHeight,
          wrap ? wrap.offsetHeight : 0
        );
        window.parent.postMessage({ type: 'grafer-resize', height: height }, '*');
      }
    }

    window.addEventListener('load', () => {
      setTimeout(sendHeight, 200);
      setTimeout(sendHeight, 500);
      setTimeout(sendHeight, 1000);
      setTimeout(sendHeight, 2000);
    });

    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(sendHeight, 100);
    });

    const resizeObserver = new ResizeObserver(() => {
      sendHeight();
    });
    resizeObserver.observe(document.body);

    let attempts = 0;
    const interval = setInterval(() => {
      sendHeight();
      attempts++;
      if (attempts > 10) clearInterval(interval);
    }, 300);
  </script>
</body>

</html>
